#!/usr/bin/env python

import re
import json
import argparse
import subprocess
from os import sys, path, walk


def is_equal(obj1, obj2):
    e = True
    if type(obj1) == list and type(obj2) == list:
        for i in range(len(obj1)):
            if not is_equal(obj1[i], obj2[i]):
                e = False
                break
    elif type(obj1) == dict and type(obj2) == dict:
        for p in obj1:
            if not is_equal(obj1.get(p), obj2.get(p)):
                e = False
                break
    else:
        e = obj1 == obj2
    return e


def run(cmd, return_prcss=False, inputs=None):
    process = subprocess.Popen(cmd, shell=True,
                               stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    if return_prcss:
        return process
    if inputs:
        stdouts = []
        stderrs = []
        for i in inputs:
            out, err = process.communicate(i.encode())
            stdouts.append(out.decode())
            stderrs.append(err.decode())
        return stdouts, stderrs, process.returncode
    out, err = process.communicate()
    return out.decode(), err.decode(), process.returncode


def get_tests(directory='أكواد', clean=False, fill=False):
    tests = []
    tree = walk(directory)  # top-down tree
    for (full_path, dirs, files) in tree:
        alif_files = filter(lambda f: re.compile(
            r'.(ألف|alif)$').findall(f), files)
        for f in alif_files:
            name = re.compile(r'(.*)\.(?:ألف|alif)$').findall(f)[0]
            expect_file = None
            if not clean:
                expect_file = path.join(full_path, f"{name}_توقع.json")
                expect_file = expect_file if path.exists(expect_file) else None
            if fill and expect_file:
                continue
            code_file = path.join(full_path, f)
            t = {
                "full_path": full_path,
                "tests": [{
                    "name": name, "code_file": code_file,
                    "expect_file": expect_file}]
            }
            tests.append(t)

        if dirs:
            for d in dirs:
                sub_tests = get_tests(d)
                tests.extend(sub_tests)

    return tests


def test_unit(tt, full_path, syntax_only):
    SYNTAX_ONLY = "<قواعد فقط>"
    name = tt.get('name')
    code_file = tt.get("code_file")
    expect_file = tt.get("expect_file")
    exec_file = path.join(full_path, f"{name}_تنفيذي")
    exec_file = path.abspath(exec_file)
    log_file = path.join(full_path, f"{name}_سجل")

    execs_stds = None
    execs_inputs = None
    compi_inputs = None
    if expect_file:
        with open(expect_file, "r") as f:
            expected_behaviour = json.loads(f.read())
            compi_inputs = expected_behaviour.get('تجميع').get('دخل')
            expected_exec = expected_behaviour.get('تنفيذ')
            if expected_exec and expected_exec != SYNTAX_ONLY:
                execs_inputs = map(lambda r: r.get('دخل'), expected_exec)
            if syntax_only:
                expected_behaviour["تنفيذ"] = SYNTAX_ONLY

    syntax_only = '--syntax-only' if syntax_only else ''
    compile_stdout, compile_stderr, compile_exitcode = \
        run(f"alif '{code_file}' {syntax_only} --o '{exec_file}' --log-json '{log_file}'",
            inputs=compi_inputs)
    if not compile_exitcode and not syntax_only:
        execs_stds = \
            map(lambda i: (i, *run(f"'{exec_file}'", inputs=i)), execs_inputs) \
            if execs_inputs else [(None, *run(f"'{exec_file}'"))]

    logs = None
    if compile_exitcode:
        with open(log_file, "r") as f:
            logs = json.loads(f.read())

    real_behaviour = {
        "تنفيذ": [*map(lambda stds: {
            "رمز_الخروج": stds[3],
            "دخل": stds[0],
            "خرج": stds[1],
            "خطأ": stds[2]
        }, execs_stds)]
        if execs_stds else SYNTAX_ONLY
        if syntax_only else None,  # if no error occured
        "تجميع": {
            "رمز_الخروج": compile_exitcode,
            "دخل": compi_inputs,
            "خرج": compile_stdout,
            "خطأ": compile_stderr,
            "سجل": logs
        }
    }

    if not expect_file:
        expect_file = path.join(full_path, f"{name}_توقع.json")
        with open(expect_file, "w") as f:
            f.write(json.dumps(real_behaviour, indent=2, ensure_ascii=False))
        print("    📝: ", expect_file)
        return

    if not syntax_only and expected_behaviour.get("تنفيذ") == SYNTAX_ONLY:
        equal = is_equal(real_behaviour.get("ترجمة"),
                         expected_behaviour.get("ترجمة"))
        if equal:
            with open(expect_file, "w") as f:
                f.write(json.dumps(real_behaviour, indent=2, ensure_ascii=False))
            print("    ✅️📝: " + code_file)
        else:
            print("    ❌️: " + code_file)
            print(json.dumps(real_behaviour, indent=2, ensure_ascii=False))
        return

    equal = is_equal(real_behaviour, expected_behaviour)
    if equal:
        print("    ✅️: " + code_file)
    else:
        print("    ❌️: " + code_file)
        print(json.dumps(real_behaviour, indent=2, ensure_ascii=False))


def test_all(tests, syntax_only=False):
    for t in tests:
        for tt in t.get("tests"):
            test_unit(tt, t.get("full_path"), syntax_only)


if __name__ == "__main__":
    if run("alif")[1]:
        print("مترجم ألف غير مثبت لديك، قم بالبناء أولا أو نزله مبنيا جاهزا\n", file=sys.stderr)
        exit(1)

    args_parser = argparse.ArgumentParser(
        description='إجراء اختبارات لمترجم ألف.', add_help=False)
    args_parser.add_argument(
        "--مساعدة", "-م", help="احصل على رسالة المساعدة هذه", action="store_true")
    args_parser.add_argument(
        "--تكميل", "-ك", help="بانتاج ملفات التوقع الغير موجودة من خلال ما يحدث فعلا عند ترجمة وتنفيذ الكود", action="store_true")
    args_parser.add_argument(
        "--القواعد-فقط", "-ق", help="اختبار القواعد فقط بدون الخَرج أو الترجمة الكاملة", action="store_true")
    args_parser.add_argument(
        "--تجديد", "-ج", help="إعادة انتاج كل التوقعات من الكود وإهمال القديم. هذه الأمر لابد أن تكون واعيا بتبعاته", action="store_true")
    args_parser.add_argument(
        "--مسار", "-س", help="تحديد مسار لجمع الاختبارات منه ومن المسارات الفرعية بداخلة", default="أكواد")
    args = args_parser.parse_args()

    tests = get_tests(args.مسار, clean=args.تجديد, fill=args.تكميل)

    if (args.مساعدة):
        help_msg = args_parser.format_help()
        help_msg = "الاستخدام" + \
            help_msg[5:].replace("optional arguments", "أَسْناد غير إلزامية")
        print(help_msg)
        exit(0)

    test_all(tests, syntax_only=args.القواعد_فقط)
