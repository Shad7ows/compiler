#!/usr/bin/env python

import re
import json
import argparse
import subprocess
from colors import *
from os import sys, path, walk


SUCCESS = 1
FAILURE = 0


def is_equal(dict1, dict2, msg):
    equal = True

    for p in dict1:
        if dict1.get(p) != dict2.get(p):
            equal = False
            break

    if (equal):
        msg = color("    ✅️:", fg="green") + msg
    else:
        msg = color("    ❌️:", fg="red") + msg

    return equal, msg


def run(cmd, return_prcss=False):
    process = subprocess.Popen(cmd, shell=True,
                               stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    if return_prcss:
        return process
    out, err = process.communicate()
    out = "".join([chr(i) for i in out])
    err = "".join([chr(i) for i in err])
    return out, err, process.returncode


def get_tests(directory='أكواد', clean=False):
    tests = []
    tree = walk(directory)  # top-down tree
    for (full_path, dirs, files) in tree:
        alif_files = filter(lambda f: re.compile(
            r'.(ألف|alif)$').findall(f), files)
        for f in alif_files:
            name = re.compile(r'(.*)\.(?:ألف|alif)$').findall(f)[0]
            expect_file = None
            if not clean:
                expect_file = path.join(full_path, f"{name}_توقع.json")
                expect_file = expect_file if path.exists(expect_file) else None
            code_file = path.join(full_path, f)
            t = {
                "full_path": full_path,
                "tests": [{
                    "name": name, "code_file": code_file,
                    "expect_file": expect_file}]
            }
            tests.append(t)

        if dirs:
            for d in dirs:
                sub_tests = get_tests(d)
                tests.extend(sub_tests)

    return tests


def test_unit(tt, full_path):
    name = tt.get('name')
    code_file = tt.get("code_file")
    expect_file = tt.get("expect_file")
    exec_file = path.join(full_path, f"{name}_تنفيذي")
    log_file = path.join(full_path, f"{name}_سجل")

    compile_stdout, compile_stderr, compile_exitcode = \
        run(f"alif '{code_file}' --o '{exec_file}' --log-json '{log_file}'")
    stdout, stderr, exitcode = \
        run(f"./'{exec_file}'")

    logs = None
    if compile_exitcode:
        with open(log_file, "r") as f:
            logs = json.loads(f.read())

    real_behaviour = {
        "execution": {
            "exitcode": exitcode,
            "stdout": stdout,
            "stderr": stderr
        },
        "compilation": {
            "exitcode": compile_exitcode,
            "stdout": compile_stdout,
            "stderr": compile_stderr,
            "logs": logs
        }
    }

    if not expect_file:
        expect_file = path.join(full_path, f"{name}_توقع.json")
        with open(expect_file, "w") as f:
            f.write(json.dumps(real_behaviour, indent=2))
        print(color("    📝:", fg="green"), expect_file)
        return

    with open(expect_file, "r") as f:
        expected_behaviour = json.loads(f.read())

    _, msg = is_equal(real_behaviour, expected_behaviour, code_file)
    print(msg)


def test_all(tests, syntax_only=False):
    for t in tests:
        for tt in t.get("tests"):
            test_unit(tt, t.get("full_path"))


if __name__ == "__main__":
    print(run("alif")[1])
    if run("alif")[1]:
        sys.stderr.write(
            "مترجم ألف غير مثبت لديك، قم بالبناء أولا أو نزله مبنيا جاهزا\n")
        exit(1)

    args_parser = argparse.ArgumentParser(
        description='إجراء اختبارات لمترجم ألف.', add_help=False)
    args_parser.add_argument(
        "--مساعدة", "-م", help="احصل على رسالة المساعدم هذه", action="store_true")
    args_parser.add_argument(
        "--القواعد-فقط", "-ق", help="اختبار القواعد فقط بدون الخَرج", action="store_true")
    args_parser.add_argument(
        "--توقع", help="إعادة انتاج كل التوقعات من الكود وإهمال القديم. هذه الأمر لابد أن تكون واعيا بتبعاته", action="store_true")
    args = args_parser.parse_args()

    tests = get_tests(clean=args.توقع)

    if (args.مساعدة):
        help_msg = args_parser.format_help()
        help_msg = "الاستخدام" + \
            help_msg[5:].replace("optional arguments", "أَسْناد غير إلزامية")
        print(help_msg)
        exit(0)

    test_all(tests, syntax_only=args.القواعد_فقط)
